<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Калькулятор Науковий - Все в одному</title>
    <style>
        /* CSS стилі починаються тут */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #e9e9e9; /* Трохи світліший фон */
        }

        .calculator {
            background-color: #dcdcdc; /* Фон калькулятора */
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            width: 95%;
            max-width: 450px; /* Збільшимо максимальну ширину */
            border: 1px solid #bbb;
        }

        .display-container {
             background-color: #f0f0f0; /* Фон дисплея */
             color: #222;
             padding: 10px 15px;
             border-bottom: 1px solid #bbb;
             min-height: 100px; /* Збільшимо висоту */
             display: flex;
             flex-direction: column;
             justify-content: space-between;
             position: relative; /* Для позиціонування індикаторів */
        }

        .display-indicators {
            position: absolute;
            top: 5px;
            left: 15px;
            font-size: 0.8em;
            color: #555;
        }
        #memory-indicator, #angle-indicator {
             margin-right: 10px;
             font-weight: bold;
             display: inline-block; /* Щоб не зливалися */
             min-width: 15px; /* Резервуємо місце */
             text-align: center;
        }


        .previous-operand { /* Тепер показує попередній результат/помилку */
            color: #555;
            font-size: 0.9em;
            min-height: 20px;
            text-align: right;
        }

        .current-operand { /* Тепер показує поточний вираз */
            color: #111;
            font-size: 1.8em; /* Зменшимо трохи для довших виразів */
            font-weight: 500;
            min-height: 50px;
            text-align: right;
            word-wrap: break-word;
            word-break: break-all;
            overflow-y: auto; /* Додамо скрол, якщо вираз дуже довгий */
            max-height: 70px; /* Обмеження висоти, щоб скрол з'являвся */
        }


        .buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* 5 стовпців */
            gap: 1px;
            background-color: #bbb; /* Колір проміжків */
        }

        button {
            background-color: #f8f8f8; /* Світлі кнопки */
            border: none;
            padding: 15px 0; /* Зменшимо падінг */
            font-size: 1.1em; /* Зменшимо шрифт */
            cursor: pointer;
            transition: background-color 0.15s ease;
            color: #333;
            text-align: center;
        }
        button:hover {
            background-color: #eee;
        }
        button:active {
            background-color: #ddd;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        /* Стилі для різних типів кнопок */
        button[data-action="number"] {
            background-color: #fff;
            font-weight: 500;
        }
        button[data-action="number"]:hover { background-color: #f5f5f5; }
        button[data-action="number"]:active { background-color: #eee; }

        button.operator,
        button[data-action="parenthesis"],
        button[data-action="power"] {
            background-color: #f0f0f0;
            color: #444;
        }
        button.operator:hover,
        button[data-action="parenthesis"]:hover,
        button[data-action="power"]:hover { background-color: #e8e8e8; }
        button.operator:active,
        button[data-action="parenthesis"]:active,
        button[data-action="power"]:active { background-color: #ddd; }

        button.function,
        button[data-action="trig"],
        button[data-action="log"],
        button[data-action="factorial"],
        button[data-action="constant"],
        button[data-action="memory"],
        button[data-action="clear"],
        button[data-action="negate"],
        button[data-action="delete"] {
            background-color: #e8e8e8; /* Ще трохи темніші для функцій */
            color: #333;
        }
        button.function:hover, /* ... і так далі для :hover та :active */
        button[data-action="trig"]:hover,
        button[data-action="log"]:hover,
        button[data-action="factorial"]:hover,
        button[data-action="constant"]:hover,
        button[data-action="memory"]:hover,
        button[data-action="clear"]:hover,
        button[data-action="negate"]:hover,
        button[data-action="delete"]:hover {
             background-color: #ddd;
         }
        button.function:active, /* ... */
        button[data-action="trig"]:active,
        button[data-action="log"]:active,
        button[data-action="factorial"]:active,
        button[data-action="constant"]:active,
        button[data-action="memory"]:active,
        button[data-action="clear"]:active,
        button[data-action="negate"]:active,
        button[data-action="delete"]:active {
             background-color: #ccc;
        }


        button.equals {
            background-color: #add8e6; /* Світло-блакитний */
            color: #191970; /* Темно-синій */
            font-weight: bold;
            grid-column: span 2; /* Розтягнути на 2 стовпці */
        }
        button.equals:hover { background-color: #9acced; }
        button.equals:active { background-color: #87ceeb; }

        button[data-value="RAD"].active-mode { /* Стиль для активного режиму кутів */
             background-color: #b0e0e6; /* Пудрово-синій */
             box-shadow: inset 0 0 3px rgba(0,0,0,0.2);
        }


        /* Адаптивність */
        @media (max-width: 400px) {
            .current-operand { font-size: 1.6em; }
            button { font-size: 1em; padding: 12px 0;}
            .display-container { min-height: 80px; }
        }
        /* CSS стилі закінчуються тут */
    </style>
</head>
<body>
    <div class="calculator">
        <div class="display-container">
             <div class="display-indicators">
                 <span id="memory-indicator"></span>
                 <span id="angle-indicator">RAD</span>
             </div>
            <div id="previous-operand" class="previous-operand"></div>
            <div id="current-operand" class="current-operand">0</div>
        </div>
        <div class="buttons">
            <button data-action="memory" data-value="MC">MC</button>
            <button data-action="memory" data-value="MR">MR</button>
            <button data-action="memory" data-value="MS">MS</button>
            <button data-action="memory" data-value="M+">M+</button>
            <button data-action="memory" data-value="M-">M-</button>

            <button data-action="angle-mode" data-value="RAD" class="active-mode">RAD</button> <button data-action="trig" data-value="sin(">sin</button>
            <button data-action="trig" data-value="cos(">cos</button>
            <button data-action="trig" data-value="tan(">tan</button>
            <button data-action="delete" data-value="DEL">DEL</button>

            <button data-action="power" data-value="**">xʸ</button>
            <button data-action="log" data-value="log10(">log</button>
            <button data-action="log" data-value="log(">ln</button>
            <button data-action="parenthesis" data-value="(">(</button>
            <button data-action="parenthesis" data-value=")">)</button>

            <button data-action="function" data-value="sqrt(">√x</button>
            <button data-action="number" data-value="7">7</button>
            <button data-action="number" data-value="8">8</button>
            <button data-action="number" data-value="9">9</button>
            <button data-action="operator" data-value="/" class="operator">&divide;</button>

            <button data-action="factorial" data-value="factorial(">n!</button>
            <button data-action="number" data-value="4">4</button>
            <button data-action="number" data-value="5">5</button>
            <button data-action="number" data-value="6">6</button>
            <button data-action="operator" data-value="*" class="operator">&times;</button>

            <button data-action="constant" data-value="PI">π</button>
            <button data-action="number" data-value="1">1</button>
            <button data-action="number" data-value="2">2</button>
            <button data-action="number" data-value="3">3</button>
            <button data-action="operator" data-value="-" class="operator">-</button>

             <button data-action="constant" data-value="E">e</button>
            <button data-action="negate" data-value="+/-">+/-</button>
            <button data-action="number" data-value="0">0</button>
            <button data-action="decimal" data-value=".">.</button>
            <button data-action="operator" data-value="+" class="operator">+</button>

             <button data-action="clear" data-value="AC">AC</button>
             <button data-action="clear" data-value="CE">CE</button> <button data-action="equals" class="equals" data-value="=">=</button> </div>
    </div>

    <script>
        // JavaScript код починається тут

        // Додаємо функцію факторіалу глобально для new Function()
        window.factorial = function(n) {
            if (n < 0) return NaN;
            if (n > 170) return Infinity; // Обмеження для JS
            if (n === 0 || n === 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) {
                result *= i;
            }
            return result;
        }

        class ScientificCalculator {
            constructor(previousOperandTextElement, currentOperandTextElement, memoryIndicator, angleIndicator) {
                this.previousOperandTextElement = previousOperandTextElement;
                this.currentOperandTextElement = currentOperandTextElement;
                this.memoryIndicator = memoryIndicator;
                this.angleIndicator = angleIndicator; // Поки не використовується для обчислень
                this.isRadians = true; // За замовчуванням радіани
                this.memoryValue = 0;
                this.clearAll();
                this.updateDisplay();
            }

            // --- Стан та Очищення ---
            clearAll() {
                this.currentExpression = '0'; // Основний рядок, що редагується
                this.previousResult = '';     // Останній обчислений результат
                this.isResultDisplayed = true; // Чи показується результат, чи вводиться вираз
                this.openParentheses = 0;    // Лічильник відкритих дужок
                // Не скидаємо пам'ять та режим кутів при AC
                this.updateDisplay();
            }

            clearEntry() {
                // Скидає поточний ввід до 0, але зберігає попередні частини виразу
                // Це складно реалізувати правильно з рядком виразу, тому поки що CE=AC
                 this.clearAll(); // Спрощена реалізація CE
            }

            // --- Ввід Даних ---
            appendNumber(number) {
                 if (this.isResultDisplayed) {
                     this.currentExpression = number;
                     this.isResultDisplayed = false;
                 } else {
                    // Заборона кількох нулів на початку числа
                     if (number === '0' && this.currentExpression.match(/(^|[\s(*+/-^])0$/)) return;
                     // Якщо останній символ - закриваюча дужка або константа, додаємо "*"
                     if (this.currentExpression.match(/[)eπ]$/i)) {
                          this.currentExpression += '*';
                     }
                     this.currentExpression += number;
                 }
            }

            appendDecimal() {
                if (this.isResultDisplayed) {
                    this.currentExpression = '0.';
                    this.isResultDisplayed = false;
                    return;
                }
                 // Знаходимо останнє число у виразі
                 const match = this.currentExpression.match(/[\d.]+$/);
                 // Дозволяємо крапку, тільки якщо її ще немає в останньому числі
                 if (match && match[0].includes('.')) return;

                 // Якщо останній символ не цифра, додаємо "0." (напр. після оператора)
                 if (!this.currentExpression.match(/[\d]$/)) {
                     // Якщо останнє - константа або ) додаємо *
                     if (this.currentExpression.match(/[eπ)]$/i)) {
                         this.currentExpression += '*0.';
                     } else {
                         this.currentExpression += '0.';
                     }
                 } else {
                     this.currentExpression += '.';
                 }
            }

            appendOperator(operator) {
                if (this.currentExpression.toString().startsWith('Error:')) return;
                 this.isResultDisplayed = false;
                 // Заміна останнього оператора, якщо вони несумісні (напр., +-)
                 // Додаємо пробіли для кращої читабельності (хоча для new Function не обов'язково)
                 if (this.currentExpression.match(/[+\-*/^]\s$/)) {
                     this.currentExpression = this.currentExpression.slice(0, -2) + operator + ' ';
                 } else if (this.currentExpression !== '' && this.currentExpression !== '0' && this.currentExpression !== '-') {
                     this.currentExpression += ' ' + operator + ' ';
                 } else if (operator === '-' && (this.currentExpression === '0' || this.currentExpression === '')) {
                      // Дозволяємо почати з унарного мінуса
                      this.currentExpression = '-';
                 }
            }

             appendPowerOperator() {
                 if (this.currentExpression.toString().startsWith('Error:') || this.currentExpression.match(/[+\-*/(]\s?$/) || this.currentExpression === '' || this.currentExpression === '0') return; // Не ставити степінь після оператора або на початку
                 this.isResultDisplayed = false;
                 this.currentExpression += '**'; // Використовуємо ** для степеня в JS
             }

            appendParenthesis(paren) {
                if (this.isResultDisplayed && paren === '(') {
                     this.currentExpression = '(';
                     this.isResultDisplayed = false;
                     this.openParentheses++;
                     return;
                }
                 this.isResultDisplayed = false;

                 if (paren === '(') {
                     // Якщо останній символ - цифра, константа або ), додаємо множення
                     if (this.currentExpression.match(/[\d.)eπ]$/i)) {
                         this.currentExpression += '*(';
                     } else {
                         this.currentExpression += '(';
                     }
                     this.openParentheses++;
                 } else if (paren === ')') {
                     // Додаємо дужку, тільки якщо є відкриті і останній символ дозволяє
                     if (this.openParentheses > 0 && !this.currentExpression.match(/[+\-*/(.\s]$/)) {
                         this.currentExpression += ')';
                         this.openParentheses--;
                     }
                 }
            }

            appendFunction(func) { // 'sin(', 'log(', 'sqrt(', 'factorial('
                 if (this.isResultDisplayed) {
                     this.currentExpression = func;
                     this.isResultDisplayed = false;
                 } else {
                    // Якщо останній символ - цифра, константа або ), додаємо множення
                     if (this.currentExpression.match(/[\d.)eπ]$/i)) {
                         this.currentExpression += '*' + func;
                     } else {
                         this.currentExpression += func;
                     }
                 }
                 if (!func.startsWith('factorial')) { // Факторіал не додає дужку для лічильника
                     this.openParentheses++;
                 }
            }

            appendConstant(constSymbol) { // 'PI', 'E'
                 const constValue = constSymbol === 'PI' ? 'π' : 'e';
                 if (this.isResultDisplayed) {
                     this.currentExpression = constValue;
                     this.isResultDisplayed = false;
                 } else {
                    // Якщо останній символ - цифра, константа або ), додаємо множення
                     if (this.currentExpression.match(/[\d.)eπ]$/i)) {
                         this.currentExpression += '*' + constValue;
                     } else {
                         this.currentExpression += constValue;
                     }
                 }
            }


            // --- Видалення ---
            deleteLast() {
                 if (this.isResultDisplayed) return; // Не видаляти результат
                 if (this.currentExpression === '0' || this.currentExpression === '') {
                     this.currentExpression = '0';
                     return;
                 }

                 let deleted = false;
                 // Спробувати видалити функції типу sin(, log(, sqrt(, fact(
                 const funcMatch = this.currentExpression.match(/(sin|cos|tan|log10|log|sqrt|factorial)\($/i);
                 if (funcMatch) {
                     this.currentExpression = this.currentExpression.slice(0, -funcMatch[0].length);
                     if (!funcMatch[0].startsWith('factorial')) { // Не зменшувати для факторіалу
                         this.openParentheses--;
                     }
                     deleted = true;
                 }

                 // Спробувати видалити оператор з пробілами або степінь
                 if (!deleted && this.currentExpression.match(/(\s[+\-*/]\s|\*\*)$/)) {
                     this.currentExpression = this.currentExpression.replace(/(\s[+\-*/]\s|\*\*)$/, '');
                     deleted = true;
                 }

                 // Видалити константу або дужку
                  if (!deleted && this.currentExpression.match(/[()πe]$/i)) {
                     const lastChar = this.currentExpression.slice(-1);
                      this.currentExpression = this.currentExpression.slice(0, -1);
                      if (lastChar === '(') this.openParentheses--;
                      else if (lastChar === ')') this.openParentheses++; // Збільшуємо, бо видалили закриваючу
                      deleted = true;
                  }

                 // Видалити звичайний символ (цифру, крапку)
                 if (!deleted) {
                    const lastChar = this.currentExpression.slice(-1);
                    if (lastChar === '(') this.openParentheses--; // На випадок, якщо вище не спрацювало
                    else if (lastChar === ')') this.openParentheses++;
                    this.currentExpression = this.currentExpression.slice(0, -1);
                 }

                  // Якщо після видалення рядок порожній, ставимо "0"
                  if (this.currentExpression === '' || this.currentExpression === '-') {
                      this.currentExpression = '0';
                  }
                 this.updateDisplay(); // Оновлюємо одразу
            }


            // --- Інші Функції ---
            negate() {
                // TODO: Реалізувати коректну зміну знаку останнього числа у виразі
                // Це складно зробити надійно з рядком, тому поки що не реалізовано
                console.warn("Negate function needs proper implementation for expression strings.");
            }

            toggleAngleMode() {
                // Поки не впливає на обчислення, тільки на індикатор
                this.isRadians = !this.isRadians;
                this.updateDisplay();
            }

            // --- Пам'ять ---
            handleMemory(operation) {
                let currentValue = NaN;
                 // Спробуємо отримати поточне число або результат обчислення
                 if (this.isResultDisplayed && this.previousResult !== '' && !this.previousResult.startsWith('Error')) {
                     currentValue = parseFloat(this.previousResult);
                 } else {
                     try {
                         // Спроба обчислити поточний вираз для MS, M+, M-
                         const result = this.evaluateExpression(this.currentExpression);
                         currentValue = result;
                     } catch {
                         currentValue = NaN; // Не вдалося обчислити
                     }
                 }


                 switch(operation) {
                     case 'MC': // Memory Clear
                         this.memoryValue = 0;
                         break;
                     case 'MR': // Memory Recall
                          if (this.isResultDisplayed) {
                              this.currentExpression = this.memoryValue.toString();
                              this.isResultDisplayed = false;
                          } else {
                              // Якщо останнє число/константа/дужка - додаємо множення
                              if (this.currentExpression.match(/[\d.)eπ]$/i)) {
                                  this.currentExpression += '*' + this.memoryValue.toString();
                              } else {
                                  this.currentExpression += this.memoryValue.toString();
                              }
                          }
                          break;
                     case 'MS': // Memory Store
                         if (!isNaN(currentValue)) {
                             this.memoryValue = currentValue;
                         } else {
                              this.previousOperandTextElement.innerText = "Cannot store non-numeric value";
                         }
                         break;
                     case 'M+': // Memory Add
                         if (!isNaN(currentValue)) {
                             this.memoryValue += currentValue;
                         } else {
                              this.previousOperandTextElement.innerText = "Cannot add non-numeric value";
                         }
                         break;
                     case 'M-': // Memory Subtract
                         if (!isNaN(currentValue)) {
                             this.memoryValue -= currentValue;
                         } else {
                               this.previousOperandTextElement.innerText = "Cannot subtract non-numeric value";
                         }
                         break;
                 }
                 this.updateDisplay();
            }

             // --- Обчислення ---
             evaluateExpression(expression) {
                 // 1. Перевірка та закриття дужок
                 let evalExpression = expression.trim();
                 if (this.openParentheses > 0) {
                     evalExpression += ')'.repeat(this.openParentheses);
                 }
                 this.openParentheses = 0; // Скидаємо лічильник після спроби закрити

                 // 2. Заміна символів на JS еквіваленти
                 evalExpression = evalExpression
                     .replace(/π/g, 'Math.PI')
                     .replace(/e/g, 'Math.E')
                     .replace(/log10\(/g, 'Math.log10(')
                     .replace(/log\(/g, 'Math.log(')    // ln -> Math.log
                     .replace(/sqrt\(/g, 'Math.sqrt(')
                     .replace(/sin\(/g, 'Math.sin(')    // Поки тільки радіани
                     .replace(/cos\(/g, 'Math.cos(')
                     .replace(/tan\(/g, 'Math.tan(')
                     .replace(/factorial\(/g, 'window.factorial(') // Використовуємо глобальну функцію
                     .replace(/\^/g, '**') // Залишаємо, хоча зараз використовуємо **
                     .replace(/\s/g, ''); // Видаляємо пробіли перед обчисленням

                 // 3. Обчислення за допомогою new Function (НЕБЕЗПЕЧНО!)
                 // ** ПОПЕРЕДЖЕННЯ: Цей метод небезпечний для реальних застосунків! **
                 const calculate = new Function('return ' + evalExpression);
                 let result = calculate();

                 // 4. Перевірка результату
                 if (!isFinite(result)) {
                     if (isNaN(result)) throw new Error("Невірний вираз");
                     else throw new Error("Ділення на нуль або переповнення");
                 }
                 // Обмеження точності
                 return parseFloat(result.toPrecision(15)); // Використовуємо toPrecision
             }


            compute() {
                if (this.currentExpression.toString().startsWith('Error:')) return;
                try {
                    const result = this.evaluateExpression(this.currentExpression);
                    this.previousResult = result.toString(); // Зберігаємо результат
                    this.currentExpression = this.previousResult; // Показуємо результат
                    this.isResultDisplayed = true; // Позначаємо, що це результат
                    this.previousOperandTextElement.innerText = ''; // Очищаємо верхній рядок
                } catch (error) {
                    this.previousResult = `Error: ${error.message}`;
                    this.currentExpression = '0'; // Скидаємо вираз при помилці
                    this.isResultDisplayed = true;
                    this.previousOperandTextElement.innerText = this.previousResult; // Показуємо помилку зверху
                }
                 this.openParentheses = 0; // Скидаємо дужки після обчислення/помилки
            }

            // --- Оновлення Дисплея ---
            updateDisplay() {
                 // Оновлення індикаторів
                 this.memoryIndicator.innerText = this.memoryValue !== 0 ? 'M' : '';
                 this.angleIndicator.innerText = this.isRadians ? 'RAD' : 'DEG';
                 // Виділення активної кнопки режиму кутів
                 document.querySelectorAll('button[data-action="angle-mode"]').forEach(btn => {
                      btn.classList.remove('active-mode');
                      if ((this.isRadians && btn.dataset.value === 'RAD') || (!this.isRadians && btn.dataset.value === 'DEG')) {
                           btn.classList.add('active-mode');
                      }
                 });


                 // Форматування основного дисплея
                 if (this.isResultDisplayed && this.previousResult.toString().startsWith('Error:')) {
                     // Якщо остання дія була помилкою, показуємо її зверху, а знизу 0
                     this.previousOperandTextElement.innerText = this.previousResult;
                     this.currentOperandTextElement.innerText = '0';
                 } else if (this.isResultDisplayed) {
                      // Показуємо результат
                      this.currentOperandTextElement.innerText = this.formatNumber(this.currentExpression);
                      this.previousOperandTextElement.innerText = ''; // Очищаємо верхній рядок
                 }
                  else {
                     // Показуємо поточний вираз
                     this.currentOperandTextElement.innerText = this.currentExpression
                         .replace(/Math\.PI/g, 'π') // Показуємо символи
                         .replace(/Math\.E/g, 'e')
                         .replace(/\*\*/g, '^') // Показуємо степінь як ^
                         .replace(/window\.factorial\(/g, 'fact('); // Скорочення
                      // Можна додати показ попереднього результату зверху, якщо він є
                      if (this.previousResult && !this.previousResult.startsWith('Error:')) {
                         this.previousOperandTextElement.innerText = `Ans = ${this.formatNumber(this.previousResult)}`;
                      } else {
                         this.previousOperandTextElement.innerText = '';
                      }
                 }
                 this.adjustFontSize(); // Підгонка розміру шрифту
            }

            formatNumber(numberString) {
                 // Проста перевірка на помилку
                 if (typeof numberString !== 'string' || numberString.startsWith('Error:')) return numberString;
                try {
                    const number = parseFloat(numberString);
                    if (isNaN(number)) return numberString; // Якщо не число, повертаємо як є

                    // Використовуємо toLocaleString для форматування
                    // Замінюємо крапку на кому для українського формату
                    return number.toLocaleString('uk-UA', { maximumFractionDigits: 10 }).replace('.', ',');
                } catch {
                    return numberString; // Повертаємо рядок, якщо сталася помилка форматування
                }
            }

            adjustFontSize() {
                const element = this.currentOperandTextElement;
                const container = element.parentElement;
                let fontSize = parseFloat(window.getComputedStyle(element).fontSize);
                const baseFontSize = 1.8 * 16; // 1.8em в пікселях (приблизно)
                element.style.fontSize = (baseFontSize / 16) + 'em'; // Reset to base

                 // Проста перевірка переповнення по ширині
                 // Вимірювання scrollWidth може бути неточним для inline елементів або з word-break
                 // Цей метод потребує покращення для точності
                if (element.scrollWidth > container.clientWidth - 10) { // -10px запас
                    const ratio = (container.clientWidth - 10) / element.scrollWidth;
                    fontSize = Math.max(1.0 * 16, baseFontSize * ratio); // Не менше 1.0em
                    element.style.fontSize = (fontSize / 16) + 'em';
                }
            }

        }

        // Ініціалізація
        const previousOperandTextElement = document.getElementById('previous-operand');
        const currentOperandTextElement = document.getElementById('current-operand');
        const memoryIndicator = document.getElementById('memory-indicator');
        const angleIndicator = document.getElementById('angle-indicator');
        const buttons = document.querySelectorAll('button');

        const calculator = new ScientificCalculator(
            previousOperandTextElement,
            currentOperandTextElement,
            memoryIndicator,
            angleIndicator
        );

        // Додавання обробників подій
        buttons.forEach(button => {
            button.addEventListener('click', () => {
                const action = button.dataset.action;
                const value = button.dataset.value;

                switch (action) {
                    case 'number': calculator.appendNumber(value); break;
                    case 'decimal': calculator.appendDecimal(); break;
                    case 'operator': calculator.appendOperator(value); break;
                    case 'power': calculator.appendPowerOperator(); break;
                    case 'parenthesis': calculator.appendParenthesis(value); break;
                    case 'trig':
                    case 'log':
                    case 'function': // sqrt
                         calculator.appendFunction(value);
                         break;
                    case 'factorial': calculator.appendFunction(value); break;
                    case 'constant': calculator.appendConstant(value); break;
                    case 'equals': calculator.compute(); break;
                    case 'clear':
                         if (value === 'AC') calculator.clearAll();
                         else if (value === 'CE') calculator.clearEntry();
                         break;
                    case 'delete': calculator.deleteLast(); break;
                    case 'negate': calculator.negate(); break; // Поки що не працює
                    case 'angle-mode': calculator.toggleAngleMode(); break; // Поки тільки UI
                    case 'memory': calculator.handleMemory(value); break;
                }
                // Оновлюємо дисплей тільки якщо це не delete (він оновлює сам)
                if (action !== 'delete') {
                     calculator.updateDisplay();
                }
            });
        });

        // --- Обробка клавіатури (розширена) ---
         document.addEventListener('keydown', (event) => {
             const key = event.key;
             let buttonToClick = null;
             event.preventDefault(); // Запобігаємо більшості стандартних дій клавіш

             if (key >= '0' && key <= '9') {
                 buttonToClick = document.querySelector(`button[data-action="number"][data-value="${key}"]`);
             } else if (key === '.' || key === ',') {
                 buttonToClick = document.querySelector('button[data-action="decimal"]');
             } else if (key === '+' || key === '-' || key === '*' || key === '/') {
                 buttonToClick = document.querySelector(`button[data-action="operator"][data-value="${key}"]`);
             } else if (key === '^') {
                  buttonToClick = document.querySelector('button[data-action="power"]');
             } else if (key === '(') {
                  buttonToClick = document.querySelector('button[data-action="parenthesis"][data-value="("]');
             } else if (key === ')') {
                  buttonToClick = document.querySelector('button[data-action="parenthesis"][data-value=")"]');
             } else if (key === '!') {
                 buttonToClick = document.querySelector('button[data-action="factorial"]');
             } else if (key.toLowerCase() === 'p') { // Pi
                  buttonToClick = document.querySelector('button[data-action="constant"][data-value="PI"]');
             } else if (key.toLowerCase() === 'e') { // Euler's number
                  buttonToClick = document.querySelector('button[data-action="constant"][data-value="E"]');
             } else if (key === 'Enter' || key === '=') {
                 buttonToClick = document.querySelector('button[data-action="equals"]');
             } else if (key === 'Backspace') {
                 buttonToClick = document.querySelector('button[data-action="delete"]');
             } else if (key === 'Escape') {
                 buttonToClick = document.querySelector('button[data-action="clear"][data-value="AC"]');
             } else if (key === 'Delete') {
                 buttonToClick = document.querySelector('button[data-action="clear"][data-value="CE"]');
             }
              // Додайте інші клавіші за потреби (sin, cos, log...)

             if (buttonToClick) {
                 buttonToClick.click(); // Симулюємо клік
                 // Візуальний ефект натискання
                 buttonToClick.classList.add('active-key');
                 setTimeout(() => buttonToClick.classList.remove('active-key'), 100);
             }
         });
          // Додатковий CSS для візуального ефекту натискання клавіші
          const keyStyle = document.createElement('style');
          keyStyle.innerHTML = `
              button.active-key {
                  background-color: #ccc !important;
                  box-shadow: inset 0 2px 4px rgba(0,0,0,0.2) !important;
              }
          `;
          document.head.appendChild(keyStyle);

        // JavaScript код закінчується тут
    </script>
</body>
</html>